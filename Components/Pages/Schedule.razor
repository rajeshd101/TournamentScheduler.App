@page "/schedule"
@inject TournamentState State
@inject SchedulerService Scheduler
@inject IJSRuntime JS
@implements IDisposable
@inject NavigationManager Nav

<div class="view-section active">
    <div class="card glass-panel" style="padding:0; overflow:visible;"> <!-- Remove padding from main card to let sticky header touch edges -->
        
        <!-- Sticky Header Container -->
        <div style="position:sticky; top:0; z-index:100; background: var(--bg-app); border-bottom:1px solid var(--border); padding: 0.5rem 1rem 0.25rem 1rem; border-top-left-radius:1rem; border-top-right-radius:1rem;">
            <div class="section-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                <h1 style="font-size: 1.75rem; font-weight: 700; margin: 0; background: linear-gradient(135deg, var(--text-main) 0%, var(--text-muted) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Schedule</h1>
                <div class="actions" style="display: flex; gap: 0.75rem; align-items:center;">
                    <button class="btn secondary" @onclick="PrintSchedule" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                        <span style="opacity: 0.7;">üñ®Ô∏è</span> Export PDF
                    </button>
                    @if (_isGenerateLocked)
                    {
                        <button class="btn secondary" @onclick="UnlockGenerate" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;" title="Click to unlock and regenerate">
                            <span>üîí</span> Unlock to Regenerate
                        </button>
                    }
                    else
                    {
                        <button class="btn primary" @onclick="Generate" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                            <span style="opacity: 0.7;">‚ö°</span> Generate
                        </button>
                    }
                </div>
            </div>

            @if (State.Schedule.Any())
            {
                var totalMatches = State.Schedule.Count;
                var totalRounds = State.Schedule.Max(m => m.Round);
                var remaining = State.Schedule.Count(m => !m.Score1.HasValue || !m.Score2.HasValue);
                var currentRoundGroup = GetTimeBasedCurrentRound();
                var currentRoundDisplay = currentRoundGroup != null ? $"{currentRoundGroup.Key}" : "-";

                <div class="stats-grid" style="grid-template-columns: repeat(4, 1fr); margin-bottom:0.5rem; gap:0.5rem;">
                    <div class="stat-card" style="padding:0.75rem;">
                        <div class="stat-label" style="font-size:0.75rem; margin-bottom:0;">Total Matches</div>
                        <div class="stat-value" style="font-size:1.1rem;">@totalMatches</div>
                    </div>
                    <div class="stat-card" style="padding:0.75rem;">
                        <div class="stat-label" style="font-size:0.75rem; margin-bottom:0;">Total Rounds</div>
                        <div class="stat-value" style="font-size:1.1rem;">@totalRounds</div>
                    </div>
                    <div class="stat-card" style="padding:0.75rem;">
                        <div class="stat-label" style="font-size:0.75rem; margin-bottom:0;">Round</div>
                        <div class="stat-value" style="font-size:1.1rem;">@currentRoundDisplay</div>
                    </div>
                    <div class="stat-card" style="padding:0.75rem;">
                        <div class="stat-label" style="font-size:0.75rem; margin-bottom:0;">Remaining Matches</div>
                        <div class="stat-value" style="font-size:1.1rem;">@remaining</div>
                    </div>
                </div>
            }
        </div>

        @if (State.Schedule.Any())
        {
            @* Current Round and Next Rounds Display Section *@
            var currentRound = GetTimeBasedCurrentRound();
            var futureRounds = GetTimeBasedFutureRounds();
            
            <div style="display:flex; flex-direction:column; gap:1rem; margin: 1.5rem; margin-bottom:1.5rem;">
                @* Current Round Panel *@
                @{
                    bool isNow = currentRound != null && IsRoundActive(currentRound.First().Time);
                }
                <div class="glass-panel @(isNow ? "active-round-panel" : "")" 
                     style="padding:1rem; border-left:4px solid #ffc107; background:rgba(255,193,7,0.05); transition: all 0.3s ease;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.75rem;">
                        <div style="display:flex; align-items:center; gap:0.75rem;">
                            <h3 style="margin:0; color:#ffc107; font-size:1rem;">@(isNow ? "üî•" : "üéØ") Round @(currentRound?.Key ?? 0) @(isNow ? "(LIVE)" : "")</h3>
                            @if(isNow && currentRound != null)
                            {
                                <span class="badge" style="background:rgba(255,193,7,0.2); color:#ffc107; font-size:0.8rem; padding:2px 8px;">
                                    ‚è±Ô∏è @GetTimeRemaining(currentRound.First().Time)
                                </span>
                            }
                        </div>
                        @if(currentRound != null)
                        {
                            <span style="font-size:0.85rem; color:var(--text-muted);">@currentRound.First().Time</span>
                        }
                    </div>
                    @if(currentRound != null)
                    {
                        <div style="display:flex; flex-wrap:wrap; gap:0.5rem; margin-bottom:1rem;">
                            @foreach(var m in currentRound)
                            {
                                <div style="background:rgba(255,255,255,0.05); border-radius:6px; padding:0.5rem; flex:1; min-width:200px;">
                                    <div style="font-size:0.75rem; color:var(--text-muted); margin-bottom:0.25rem;">Court#@m.Court</div>
                                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 1rem;">
                                        <div style="display:flex; flex-direction:column; gap:4px; flex:1;">
                                            <span style="@GetPlayerStyle(m.P1)">@m.P1?.Name</span>
                                            <span style="@GetPlayerStyle(m.P2)">@m.P2?.Name</span>
                                        </div>
                                        <span style="font-weight:bold; color:var(--accent); font-size:0.9rem;">
                                            vs
                                        </span>
                                        <div style="display:flex; flex-direction:column; gap:4px; flex:1;">
                                            <span style="@GetPlayerStyle(m.P3)">@m.P3?.Name</span>
                                            <span style="@GetPlayerStyle(m.P4)">@m.P4?.Name</span>
                                        </div>
                                    </div>
                                </div>
                            }
                        </div>
                        
                        var restingCurrent = GetRestingPlayers(currentRound);
                        @if (restingCurrent.Any())
                        {
                            <div style="border-top:1px solid rgba(255,193,7,0.1); padding-top:0.75rem;">
                                <div style="font-size:0.8rem; color:#ffc107; margin-bottom:0.5rem; display:flex; align-items:center; gap:0.5rem;">
                                    <span>üçÉ Resting Players</span>
                                </div>
                                <div style="display:flex; flex-wrap:wrap; gap:0.4rem;">
                                    @foreach(var p in restingCurrent)
                                    {
                                        <span style="@GetRestingPlayerStyle(p)">@p.Name</span>
                                    }
                                </div>
                            </div>
                        }
                    }
                    else
                    {
                        <p style="color:var(--text-muted); font-size:0.9rem; margin:0;">All matches completed! üéâ</p>
                    }
                </div>
                
                @* Future Rounds Panels *@
                @foreach (var nextRound in futureRounds)
                {
                    <div class="glass-panel" style="padding:1rem; border-left:4px solid #42a5f5; background:rgba(66,165,245,0.05);">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.75rem;">
                            <h3 style="margin:0; color:#42a5f5; font-size:1rem;">‚è≠Ô∏è Round @(nextRound.Key)</h3>
                            <span style="font-size:0.85rem; color:var(--text-muted);">@nextRound.First().Time</span>
                        </div>
                        <div style="display:flex; flex-wrap:wrap; gap:0.5rem; margin-bottom:1rem;">
                            @foreach(var m in nextRound)
                            {
                                <div style="background:rgba(255,255,255,0.05); border-radius:6px; padding:0.5rem; flex:1; min-width:200px;">
                                    <div style="font-size:0.75rem; color:var(--text-muted); margin-bottom:0.25rem;">Court#@m.Court</div>
                                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 1rem;">
                                        <div style="display:flex; flex-direction:column; gap:4px; flex:1;">
                                            <span style="@GetPlayerStyle(m.P1)">@m.P1?.Name</span>
                                            <span style="@GetPlayerStyle(m.P2)">@m.P2?.Name</span>
                                        </div>
                                        <span style="font-weight:bold; color:var(--text-muted); font-size:0.8rem;">vs</span>
                                        <div style="display:flex; flex-direction:column; gap:4px; flex:1;">
                                            <span style="@GetPlayerStyle(m.P3)">@m.P3?.Name</span>
                                            <span style="@GetPlayerStyle(m.P4)">@m.P4?.Name</span>
                                        </div>
                                    </div>
                                </div>
                            }
                        </div>

                        @{
                            var restingNext = GetRestingPlayers(nextRound);
                        }
                        @if (restingNext.Any())
                        {
                            <div style="border-top:1px solid rgba(66,165,245,0.1); padding-top:0.75rem;">
                                <div style="font-size:0.8rem; color:#42a5f5; margin-bottom:0.5rem; display:flex; align-items:center; gap:0.5rem;">
                                    <span>üçÉ Resting Players</span>
                                </div>
                                <div style="display:flex; flex-wrap:wrap; gap:0.4rem;">
                                    @foreach(var p in restingNext)
                                    {
                                        <span style="@GetRestingPlayerStyle(p)">@p.Name</span>
                                    }
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
        }
        else
        {
            <p style="text-align:center; padding: 2rem; color: var(--text-muted);">
                No schedule generated yet. Ensure you have enough players (min 4) and click Generate.
            </p>
        }
    </div>
</div>

<style>
    @@keyframes flash-text-amber {
        0% { text-shadow: 0 0 2px rgba(255, 193, 7, 0); color: inherit; }
        50% { text-shadow: 0 0 8px rgba(255, 193, 7, 0.8); color: #ffca28; }
        100% { text-shadow: 0 0 2px rgba(255, 193, 7, 0); color: inherit; }
    }

    .active-round-panel {
        box-shadow: 0 0 20px rgba(255, 193, 7, 0.15);
        border: 1px solid rgba(255, 193, 7, 0.4) !important;
        border-left: 6px solid #ffc107 !important;
        background: rgba(255, 193, 7, 0.08) !important;
    }
    
    .active-player-row {
        background: rgba(255, 193, 7, 0.05);
    }
    
    .active-player-text {
        animation: flash-text-amber 2s infinite ease-in-out;
        font-weight: bold;
    }

    .current-round-row {
        background: rgba(var(--primary-rgb), 0.1) !important;
        border-left: 4px solid var(--primary);
    }

    .completed-round-row {
        opacity: 0.5;
        filter: grayscale(0.8);
    }

    /* Simplified Layout for Schedule only */
    .schedule-layout {
        display: flex;
        flex-direction: column;
        width: 100%;
    }
    
    .schedule-center { 
        width: 100%; 
    }

    .schedule-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 1.5rem;
        padding-bottom: 2rem;
    }
    
    .sticky-col {
        position: sticky;
        left: 0;
        z-index: 10;
    }
</style>

@code {
    private bool _isGenerateLocked = false; // Lock generate after first use
    private System.Threading.Timer? _timer;

    protected override void OnInitialized()
    {
        State.OnChange += StateHasChanged;
        State.OnSearchChanged += StateHasChanged; // Re-render on search
        
        // Start a timer to refresh the UI every minute for the countdowns
        _timer = new System.Threading.Timer(_ => InvokeAsync(StateHasChanged), null, 1000, 60000);
    }

    public void Dispose()
    {
        State.OnChange -= StateHasChanged;
        State.OnSearchChanged -= StateHasChanged;
        _timer?.Dispose();
    }

    private async Task PrintSchedule()
    {
        await JS.InvokeVoidAsync("triggerPrint");
    }

    private void Generate()
    {
        // Only include players who are NOT Out
        var activePlayers = State.Players.Where(p => !p.IsOut).ToList();
        
        if (activePlayers.Count < 4) 
        {
            return; 
        }

        var result = Scheduler.Generate(activePlayers, State.Config);
        State.SetSchedule(result);
        _isGenerateLocked = true; // Lock after generation
    }

    private void UnlockGenerate()
    {
        _isGenerateLocked = false;
    }

    private string GetPlayerStyle(Player? p)
    {
         if (p == null) return "";
         var recent = State.Players.FirstOrDefault(x => x.Id == p.Id);
         string color = recent?.Color ?? "#333";
         string textColor = State.GetContrastColor(color);
         return $"background-color: {color}; color: {textColor}; padding: 2px 8px; border-radius: 4px; font-weight: 500; font-size: 0.85rem; text-align: center; white-space: nowrap; width: 100%; display: block;";
    }

    private string GetRestingPlayerStyle(Player? p)
    {
         if (p == null) return "";
         var recent = State.Players.FirstOrDefault(x => x.Id == p.Id);
         string color = recent?.Color ?? "#333";
         string textColor = State.GetContrastColor(color);
         return $"background-color: {color}; color: {textColor}; padding: 2px 8px; border-radius: 4px; font-weight: 500; font-size: 0.85rem; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px;";
    }

    private bool IsRoundActive(string timeStr)
    {
        if (string.IsNullOrWhiteSpace(timeStr)) return false;
        
        if (DateTime.TryParse(timeStr, out var startTime))
        {
            var now = DateTime.Now;
            var duration = TimeSpan.FromMinutes(State.Config.Duration + State.Config.BreakTime);
            return now >= startTime && now < startTime.Add(duration);
        }
        return false;
    }

    private string GetTimeRemaining(string timeStr)
    {
        if (DateTime.TryParse(timeStr, out var startTime))
        {
            var endTime = startTime.AddMinutes(State.Config.Duration);
            var remaining = endTime - DateTime.Now;
            if (remaining.TotalMinutes <= 0) return "Finishing...";
            return $"{(int)remaining.TotalMinutes}m left";
        }
        return "";
    }

    // Helper: Get current round based on time
    private IGrouping<int, Match>? GetTimeBasedCurrentRound()
    {
        var now = DateTime.Now;
        var interval = State.Config.Duration + State.Config.BreakTime;
        
        // Find the round that is currently happening
        var current = State.Schedule
            .GroupBy(m => m.Round)
            .OrderBy(g => g.Key)
            .FirstOrDefault(g => 
            {
                if (DateTime.TryParse(g.First().Time, out var startTime))
                {
                    return now >= startTime && now < startTime.AddMinutes(interval);
                }
                return false;
            });

        // If no round is currently happening, find the first round that hasn't started yet
        if (current == null)
        {
            current = State.Schedule
                .GroupBy(m => m.Round)
                .OrderBy(g => g.Key)
                .FirstOrDefault(g => 
                {
                    if (DateTime.TryParse(g.First().Time, out var startTime))
                    {
                        return startTime > now;
                    }
                    return false;
                });
        }

        return current;
    }
    
    // Helper: Get all future rounds based on time
    private IEnumerable<IGrouping<int, Match>> GetTimeBasedFutureRounds()
    {
        var current = GetTimeBasedCurrentRound();
        if (current == null) return Enumerable.Empty<IGrouping<int, Match>>();
        
        return State.Schedule
            .GroupBy(m => m.Round)
            .OrderBy(g => g.Key)
            .Where(g => g.Key > current.Key);
    }

    private List<Player> GetRestingPlayers(IGrouping<int, Match>? round)
    {
        if (round == null || State.Players == null) return new List<Player>();
        
        var playingIds = new HashSet<string>();
        foreach (var m in round)
        {
            if (m.P1?.Id != null) playingIds.Add(m.P1.Id);
            if (m.P2?.Id != null) playingIds.Add(m.P2.Id);
            if (m.P3?.Id != null) playingIds.Add(m.P3.Id);
            if (m.P4?.Id != null) playingIds.Add(m.P4.Id);
        }
        
        return State.Players
            .Where(p => p != null && !p.IsOut && !playingIds.Contains(p.Id))
            .OrderBy(p => p.Name)
            .ToList();
    }
}
